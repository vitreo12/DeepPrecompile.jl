module Precompiler

using Crayons

export find_invoke_functions

#=
This package does 2 things:

1) Generate THOROUGH precompile statements for PackageCompiler.jl

2) Generate complete precompile statements to be used in interactive sessions

=#

#=
Modus operandi:

For PackageCompiler.jl:

1) Make sure (with a @fully_precompile macro) all the inner functions used in the generation of precompile statements
   will get added to the precompile.jl generated by PackageCompiler.jl.

2) Introspect EVERY call to any function, recursively, and expose each call (with set types) to PackageCompiler.jl's snooping.

Things to watch for:
    1) code_lowered(Function, (Tuple for args))
    2) Base.method_instances(Function, (Tuple for args))
=#

function find_invoke_functions(f, types_tuple)
    println()
    find_invoke_functions_recursive(f, types_tuple)
end

#Inner types of the Tuple. Recursive search
function find_unstable_type_recursive(type_to_analyze)

    if(isa(type_to_analyze, DataType))

        #struct / mutable struct search
        for type_svec in type_to_analyze.types
            
            #If it's not a svec, it means we reached the bottom of the graph for this struct
            if(typeof(type_svec) != Core.SimpleVector)
                
                if(!isconcretetype(type_svec))
                    error("Type $type_svec in $type_to_analyze is not concrete")
                end
                
                #Go to next element if no errors
                continue
            end

            #The struct hasn't been fully checked yet.
            for type in type_svec
                
                if(!isconcretetype(type))
                    error("Type $type in $type_to_analyze is not concrete")
                end

                find_unstable_type_recursive(type)
            end
        end

        #If code gets here, it's a normal DataType (not a composed struct). Just check is it is concrete
        if(!isconcretetype(type_to_analyze))
            error("Type $type_to_analyze is not concrete")
        end
    end

    if(isa(type_to_analyze, UnionAll))
        error("Type $type_to_analyze is not concrete. Perhaps it hasn't been parametrized correctly.")
    end

    if(isa(type_to_analyze, Union))
        print(Crayon(foreground = :red), "WARNING: $type_to_analyze will generate non-specialized code.")

        #Find inner types in the Union anyway
        find_unstable_type_recursive(type_to_analyze.a)
        find_unstable_type_recursive(type_to_analyze.b)
    end

end

#Delve into each "invoke" call
function find_invoke_functions_recursive(f, types_tuple)
    
    #################################
    #Checks for constructor functions
    if(isa(f, DataType))
        if(!f.isconcretetype)
            error("Type $f is not concrete")
        end

        for type_of_field in f.types
            if(isa(type_of_field, Union))
                error("$type_of_field in $f is not concrete.")
            end

            if(isa(type_of_field, UnionAll))
                error("$type_of_field in $f is not concrete. Perhaps it hasn't been parametrized correctly.")
            end

            if(!type_of_field.isconcretetype)
                error("Type $type_of_field in $f is not concrete")
            end
        end
    end

    if(isa(f, Union))
        error("$f is not concrete.")
    end

    if(isa(f, UnionAll))
        error("Type $f is not concrete. Perhaps it hasn't been parametrized correctly.")
    end
    #################################

    #Types in the tuple
    for type in types_tuple
        find_unstable_type_recursive(type)
    end

    #Get the full typed graph for the function
    code_info_typed = code_typed(f, types_tuple)[1].first

    code_exprs = code_info_typed.code

    #println(code_info_typed)

    for code_line in code_exprs
        if(isa(code_line, Expr))
            if(code_line.head == :invoke)
                invoke_call = code_line
                
                method_instance = invoke_call.args[1]
                println(method_instance)

                method_instance_name = method_instance.def.name
                #println(method_instance_name)

                method_instance_args = method_instance.specTypes.parameters[2:end] #Ignore first one, which is the function name
                #println(method_instance_args)

                method_instance_args_tuple = tuple(method_instance_args...) #"method_instance_args..." to unpack the svec in all its components
                #println(method_instance_args_tuple)
                
                #eval(:(Main.code_warntype($method_instance_name, $method_instance_args_tuple)))
                
                #Some methods are just inner methods that do not have public exposure, so they would give errors here
                #= try
                    eval(:(find_invoke_functions_recursive($method_instance_name, $method_instance_args_tuple))) #need to wrap in expr because the "method_instance_name" is a Symbol
                catch
                    continue
                end =#

                #return
            end
        end
    end
    println()
end

end


#TESTING:
module TypeStabilityTest

using ..Precompiler

abstract type AbstractStruct end

#=
If using a::AbstractFloat, a will always be an AbstractFloat throughout the code, even if it assigned a concrete type.
Using parametric types, I can make sure to instantiate the EXACT type!!!!!!!!
=#

struct myStruct{F <: Union{AbstractFloat, Signed}, S <: Union{AbstractFloat, Signed}} <: AbstractStruct
    a::F
    b::S
end

struct myUnstableStruct <: AbstractStruct
    a::AbstractFloat
    b::Signed
end

function hello(a::AbstractFloat)
    b = floor(a)
    c = b * a
    d = c - b
    f = tanh(d)
    return f
end

function test_calc(input::AbstractStruct)
    sine_val = sin(input.a * 2pi)
    sine_val2 = cos(input.b * 2pi)
    final_val = mod(sine_val, hello(sine_val2))
    println(final_val)
    return final_val
end

function hello_there(a::Union{AbstractFloat, Signed})
    return a * a * a * a
end

function cubic_interp(a::AbstractFloat, x0::AbstractFloat, x1::AbstractFloat, x2::AbstractFloat, x3::AbstractFloat)
    c0::Float32 = x1
    c1::Float32 = 0.5f0 * (x2 - x0)
    c2::Float32 = x0 - (2.5f0 * x1) + (2.0f0 * x2) - (0.5f0 * x3)
    c3::Float32 = 0.5f0 * (x3 - x0) + (1.5f0 * (x1 - x2))
    out_value::Float32 = (((((c3 * a) + c2) * a) + c1) * a) + c0
    return out_value
end

function test_warntypes()

    println("\n************** PARAMETRIC TYPE *****************\n")
    #Stable (using parametric types)
    Main.code_warntype(test_calc, (myStruct{Float64, Int64}, ))

    #Unstable 
    println("\n************** UNSTABLE TYPE *****************\n")
    t::myUnstableStruct = myUnstableStruct(Float64(123.3), Int64(2)) #Even if declaring this..
    Main.@code_warntype test_calc(t)

    #Stable
    println("\n************** PARAMETRIC FUNCTION *****************\n")
    Main.code_warntype(cubic_interp, (Float32, Float64, Float16, Float32, Float64))

end

function test_precompiler()

    #The resulting fields in myStruct{Float64, Int64} are seen as concrete.
    find_invoke_functions(test_calc, (myStruct{Float64, Int64}, ))

    find_invoke_functions(myStruct{Float64, Int64}, (Float64, Int64))

    find_invoke_functions(hello_there, (Union{AbstractFloat, Signed},))
    #Main.code_warntype(hello_there, (Union{AbstractFloat, Signed},))

    #find_invoke_functions(myUnstableStruct, (Float64, Int64))
end

#test_warntypes()
test_precompiler()

end

#a = TypeStabilityTest.test_precompiler()